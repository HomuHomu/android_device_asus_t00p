diff --git a/services/core/java/com/android/server/WiredAccessoryManager.java b/services/core/java/com/android/server/WiredAccessoryManager.java
index 1b82ed6..8fd6385 100644
--- a/services/core/java/com/android/server/WiredAccessoryManager.java
+++ b/services/core/java/com/android/server/WiredAccessoryManager.java
@@ -60,9 +60,10 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private static final int BIT_USB_HEADSET_DGTL = (1 << 3);
     private static final int BIT_HDMI_AUDIO = (1 << 4);
     private static final int BIT_LINEOUT = (1 << 5);
+    private static final int BIT_P03_AUDIO = (1 << 6);
     private static final int SUPPORTED_HEADSETS = (BIT_HEADSET|BIT_HEADSET_NO_MIC|
                                                    BIT_USB_HEADSET_ANLG|BIT_USB_HEADSET_DGTL|
-                                                   BIT_HDMI_AUDIO|BIT_LINEOUT);
+                                                   BIT_HDMI_AUDIO|BIT_LINEOUT|BIT_P03_AUDIO);
 
     private static final String NAME_H2W = "h2w";
     private static final String NAME_USB_AUDIO = "usb_audio";
@@ -276,7 +277,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 outDevice = AudioManager.DEVICE_OUT_LINE;
             } else if (headset == BIT_USB_HEADSET_ANLG) {
                 outDevice = AudioManager.DEVICE_OUT_ANLG_DOCK_HEADSET;
-            } else if (headset == BIT_USB_HEADSET_DGTL) {
+            } else if (headset == BIT_USB_HEADSET_DGTL || headset == BIT_P03_AUDIO ) {
                 outDevice = AudioManager.DEVICE_OUT_DGTL_DOCK_HEADSET;
             } else if (headset == BIT_HDMI_AUDIO) {
                 outDevice = AudioManager.DEVICE_OUT_HDMI;
@@ -333,7 +334,6 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                         file.close();
                         curState = validateSwitchState(
                                 Integer.valueOf((new String(buffer, 0, len)).trim()));
-
                         if (curState > 0) {
                             updateStateLocked(uei.getDevPath(), uei.getDevName(), curState);
                         }
@@ -403,7 +403,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             //
             // If the kernel does not have an "hdmi_audio" switch, just fall back on the older
             // "hdmi" switch instead.
-            uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0, 0);
+            uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, BIT_P03_AUDIO, 0);
             if (uei.checkSwitchExists()) {
                 retVal.add(uei);
             } else {
diff --git a/services/core/java/com/android/server/display/DisplayAdapter.java b/services/core/java/com/android/server/display/DisplayAdapter.java
index 701b9f1..b5f1dad 100644
--- a/services/core/java/com/android/server/display/DisplayAdapter.java
+++ b/services/core/java/com/android/server/display/DisplayAdapter.java
@@ -43,6 +43,7 @@ abstract class DisplayAdapter {
     public static final int DISPLAY_DEVICE_EVENT_ADDED = 1;
     public static final int DISPLAY_DEVICE_EVENT_CHANGED = 2;
     public static final int DISPLAY_DEVICE_EVENT_REMOVED = 3;
+    public static final int DISPLAY_DEVICE_EVENT_SWITCHED = 4;
 
     /**
      * Used to generate globally unique display mode ids.
diff --git a/services/core/java/com/android/server/display/DisplayManagerService.java b/services/core/java/com/android/server/display/DisplayManagerService.java
index e8a857b..10dd5be 100644
--- a/services/core/java/com/android/server/display/DisplayManagerService.java
+++ b/services/core/java/com/android/server/display/DisplayManagerService.java
@@ -709,6 +709,10 @@ public final class DisplayManagerService extends SystemService {
             }
 
             int diff = device.mDebugLastLoggedDeviceInfo.diff(info);
+            Slog.e(TAG, "Quarx diff: " + diff + " DIFF_STATE " + DisplayDeviceInfo.DIFF_STATE);
+
+            Slog.i(TAG, "Display device changed: " + info);
+
             if (diff == DisplayDeviceInfo.DIFF_STATE) {
                 Slog.i(TAG, "Display device changed state: \"" + info.name
                         + "\", " + Display.stateToString(info.state));
@@ -744,6 +748,11 @@ public final class DisplayManagerService extends SystemService {
         scheduleTraversalLocked(false);
     }
 
+    private void handleDisplayDeviceSwitch(DisplayDevice device) {
+        Slog.i(TAG, "Quarx: Display device changed!!!");
+        handleDisplayDeviceChanged(device);
+    }
+
     private void applyGlobalDisplayStateLocked(List<Runnable> workQueue) {
         final int count = mDisplayDevices.size();
         for (int i = 0; i < count; i++) {
@@ -833,7 +842,9 @@ public final class DisplayManagerService extends SystemService {
                 sendDisplayEventLocked(displayId, DisplayManagerGlobal.EVENT_DISPLAY_CHANGED);
                 changed = true;
             }
+		Slog.e(TAG, "Quarx: FOR updateLogicalDisplaysLocked " + changed);
         }
+	Slog.e(TAG, "Quarx: updateLogicalDisplaysLocked " + changed);
         return changed;
     }
 
@@ -1122,15 +1133,22 @@ public final class DisplayManagerService extends SystemService {
         @Override
         public void onDisplayDeviceEvent(DisplayDevice device, int event) {
             switch (event) {
+                case DisplayAdapter.DISPLAY_DEVICE_EVENT_SWITCHED:
+                    handleDisplayDeviceSwitch(device);
+                    break;
+
                 case DisplayAdapter.DISPLAY_DEVICE_EVENT_ADDED:
+                    Slog.e(TAG, "Initiated DISPLAY_DEVICE_EVENT_ADDED");
                     handleDisplayDeviceAdded(device);
                     break;
 
                 case DisplayAdapter.DISPLAY_DEVICE_EVENT_CHANGED:
+                    Slog.e(TAG, "Initiated DISPLAY_DEVICE_EVENT_CHANGED");
                     handleDisplayDeviceChanged(device);
                     break;
 
                 case DisplayAdapter.DISPLAY_DEVICE_EVENT_REMOVED:
+                    Slog.e(TAG, "Initiated DISPLAY_DEVICE_EVENT_REMOVED");
                     handleDisplayDeviceRemoved(device);
                     break;
             }
diff --git a/services/core/java/com/android/server/display/LocalDisplayAdapter.java b/services/core/java/com/android/server/display/LocalDisplayAdapter.java
index b2207f3..ed4854e 100644
--- a/services/core/java/com/android/server/display/LocalDisplayAdapter.java
+++ b/services/core/java/com/android/server/display/LocalDisplayAdapter.java
@@ -120,6 +120,37 @@ final class LocalDisplayAdapter extends DisplayAdapter {
         }
     }
 
+    private void trySwitchPrimaryDisplayLocked() {
+        IBinder displayToken = SurfaceControl.getBuiltInDisplay(0);
+        Slog.w(TAG, "Quarx framework: Switch Display: 0 ");
+        if (displayToken != null) {
+            SurfaceControl.PhysicalDisplayInfo[] configs =
+                    SurfaceControl.getDisplayConfigs(displayToken);
+            if (configs == null) {
+                // There are no valid configs for this device, so we can't use it
+                Slog.w(TAG, "No valid configs found for display device 0");
+                return;
+            }
+            int activeConfig = SurfaceControl.getActiveConfig(displayToken);
+            if (activeConfig < 0) {
+                // There is no active config, and for now we don't have the
+                // policy to set one.
+                Slog.w(TAG, "No active config found for display device 0");
+                return;
+            }
+            LocalDisplayDevice device = mDevices.get(0);
+            device.updatePhysicalDisplayInfoLocked(configs, activeConfig);
+            // Display properties changed.
+            Slog.w(TAG, "Quarx framework: sendDisplayDeviceEventLocked(DISPLAY_DEVICE_EVENT_SWITCHED)");
+            sendDisplayDeviceEventLocked(device, DISPLAY_DEVICE_EVENT_SWITCHED);
+        } else {
+            Slog.w(TAG, "Quarx framework: DisplayToken Null");
+            // The display is no longer available. Ignore the attempt to add it.
+            // If it was connected but has already been disconnected, we'll get a
+            // disconnect event that will remove it from mDevices.
+        }
+    }
+
     private void tryDisconnectDisplayLocked(int builtInDisplayId) {
         LocalDisplayDevice device = mDevices.get(builtInDisplayId);
         if (device != null) {
@@ -181,6 +212,7 @@ final class LocalDisplayAdapter extends DisplayAdapter {
             mDisplayInfos = Arrays.copyOf(physicalDisplayInfos, physicalDisplayInfos.length);
             mActivePhysIndex = activeDisplayInfo;
             ArrayList<Display.ColorTransform> colorTransforms = new ArrayList<>();
+            Slog.e("LocalDisplayAdapter", "Quarx: Update physical display info, device id: " + this.mBuiltInDisplayId + ", " + mDisplayInfos.toString());
 
             // Build an updated list of all existing color transforms.
             boolean colorTransformsAdded = false;
@@ -644,9 +676,16 @@ final class LocalDisplayAdapter extends DisplayAdapter {
         @Override
         public void onHotplug(long timestampNanos, int builtInDisplayId, boolean connected) {
             synchronized (getSyncRoot()) {
-                if (connected) {
+		Slog.e(TAG,"Quarx: Initiated display switch: builtInDisplayId:" + builtInDisplayId);
+                if (builtInDisplayId == SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN
+			 && mDevices.get(builtInDisplayId) != null) {
+		Slog.e(TAG,"Quarx: trySwitchPrimaryDisplayLocked:");
+                    trySwitchPrimaryDisplayLocked();
+                } else if (connected) {
+		Slog.e(TAG,"Quarx: tryConnectDisplayLocked(builtInDisplayId)");
                     tryConnectDisplayLocked(builtInDisplayId);
                 } else {
+		Slog.e(TAG,"Quarx: tryDisconnectDisplayLocked(builtInDisplayId)");
                     tryDisconnectDisplayLocked(builtInDisplayId);
                 }
             }
diff --git a/services/core/java/com/android/server/display/LogicalDisplay.java b/services/core/java/com/android/server/display/LogicalDisplay.java
index 6dae397..613b2f2 100644
--- a/services/core/java/com/android/server/display/LogicalDisplay.java
+++ b/services/core/java/com/android/server/display/LogicalDisplay.java
@@ -20,6 +20,7 @@ import android.graphics.Rect;
 import android.view.Display;
 import android.view.DisplayInfo;
 import android.view.Surface;
+import android.util.Slog;
 
 import java.io.PrintWriter;
 import java.util.Arrays;
@@ -54,6 +55,8 @@ import libcore.util.Objects;
  * </p>
  */
 final class LogicalDisplay {
+    private static final String TAG = "LogicalDisplay";
+
     private final DisplayInfo mBaseDisplayInfo = new DisplayInfo();
 
     // The layer stack we use when the display has been blanked to prevent any
@@ -190,12 +193,14 @@ final class LogicalDisplay {
     public void updateLocked(List<DisplayDevice> devices) {
         // Nothing to update if already invalid.
         if (mPrimaryDisplayDevice == null) {
+       	    Slog.e(TAG,"Quarx :PrimaryDisplayDevice == null)");
             return;
         }
 
         // Check whether logical display has become invalid.
         if (!devices.contains(mPrimaryDisplayDevice)) {
             mPrimaryDisplayDevice = null;
+       	    Slog.e(TAG,"Quarx: !devices.contains(mPrimaryDisplayDevice== null)");
             return;
         }
 
@@ -206,6 +211,7 @@ final class LogicalDisplay {
         // mirroring over HDMI.)
         DisplayDeviceInfo deviceInfo = mPrimaryDisplayDevice.getDisplayDeviceInfoLocked();
         if (!Objects.equal(mPrimaryDisplayDeviceInfo, deviceInfo)) {
+       	    Slog.e(TAG,"Quarx: We in if!!!");
             mBaseDisplayInfo.layerStack = mLayerStack;
             mBaseDisplayInfo.flags = 0;
             if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) != 0) {
@@ -256,6 +262,7 @@ final class LogicalDisplay {
 
             mPrimaryDisplayDeviceInfo = deviceInfo;
             mInfo = null;
+       	    Slog.e(TAG,"Quarx: Update logical display, base display info: " + mBaseDisplayInfo);
         }
     }
 
